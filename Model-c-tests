import numpy as np
import matplotlib.pyplot as plt
from qutip import *
import qutip.ipynbtools as qip
from scipy.optimize import curve_fit
from scipy.interpolate import UnivariateSpline
from scipy.constants import k, hbar

Ä§ = hbar  # use standard hbar symbol

print("="*60)
print("QUANTUM DECOHERENCE SIMULATION: MODEL C")
print("Curvature-Screened Correlation Lengths")
print("="*60)

# ============================================================================
# 1. DEFINE SYSTEM AND MODEL C PARAMETERS
# ============================================================================
print("\n1. SYSTEM PARAMETERS")
print("-"*40)

# System: harmonic oscillator
m = 1e-14  # kg (nanosphere)
omega = 2*np.pi * 5e3  # Hz
x0 = np.sqrt(1/(2*m*omega))  # Zero-point motion (toy units)

print(f"Mass: {m:.1e} kg")
print(f"Frequency: {omega/(2*np.pi):.0f} Hz")
print(f"Zero-point motion: {x0:.1e} m")

# Model C parameters
Î“0 = 1e-3  # Base gravitational decoherence rate at R=0
m0 = 1e-12  # eV base mass
c_R = 1e-10  # Curvature coupling (eV^2 m^2)
R_earth = 1e-23  # Earth curvature (m^-2)
R_neutron = 1e-16  # Neutron star orbit curvature (m^-2)
R0 = 1e-3  # Reference length (m)

def gamma_grav(R):
    """Model C gravitational decoherence rate"""
    m_eff = np.sqrt(m0**2 + c_R * np.abs(R))
    R_c = 1/m_eff  # Correlation length
    return Î“0 * (R0 / R_c)**3

print(f"\nÎ“_grav(Earth): {gamma_grav(R_earth):.2e} s^-1")
print(f"Î“_grav(Neutron star): {gamma_grav(R_neutron):.2e} s^-1")
print(f"Ratio: {gamma_grav(R_neutron)/gamma_grav(R_earth):.1f}")

# ============================================================================
# 2. TWO-BATH LINDBLAD SUPEROPERATOR
# ============================================================================
print("\n2. TWO-BATH LINDBLAD MASTER EQUATION")
print("-"*40)

def two_bath_lindbladian(Î“_env, Î“_grav, Ï_cross=0.5):
    """
    Returns Lindbladian for two correlated baths:
    Î“_tot = Î“_env + Î“_grav + 2Ïâˆš(Î“_env Î“_grav)
    """
    # System operators
    a = destroy(2)  # Simple qubit approximation
    Ïƒx = a + a.dag()
    
    # Lindblad operators for two baths
    L_env = np.sqrt(Î“_env) * Ïƒx
    L_grav = np.sqrt(Î“_grav) * Ïƒx
    
    # Standard Lindblad terms
    H = 0  # No Hamiltonian evolution for pure decoherence
    
    # Individual decoherence terms
    L_terms = [
        [L_env, L_env.dag()],
        [L_grav, L_grav.dag()]
    ]
    
    # Cross-correlation term (Ï â‰  0)
    if abs(Ï_cross) > 0:
        L_cross = np.sqrt(Ï_cross * np.sqrt(Î“_env * Î“_grav)) * Ïƒx
        L_terms.append([L_cross, L_cross.dag()])
    
    return liouvillian(H, L_terms)

# ============================================================================
# 3. SIMULATE DECOHERENCE FOR VARYING Î“_env
# ============================================================================
print("\n3. SIMULATING DECOHERENCE SIGNATURES")
print("-"*40)

# Environmental rates to scan
Î“_env_values = np.logspace(-4, 2, 20)  # s^-1
Î“_grav_fixed = gamma_grav(R_earth)

# Initialize
times = np.linspace(0, 10, 100)  # 10 seconds
Ï0 = ket2dm(basis(2, 0) + basis(2, 1)) / np.sqrt(2)  # Coherent superposition
coherences = []

print(f"Scanning {len(Î“_env_values)} Î“_env values...")
print(f"Fixed Î“_grav = {Î“_grav_fixed:.2e} s^-1")

for Î“_env in Î“_env_values:
    # Create Lindbladian
    L = two_bath_lindbladian(Î“_env, Î“_grav_fixed, Ï_cross=0.5)
    
    # Solve master equation
    result = mesolve(L, Ï0, times, [], [])
    
    # Extract coherence (off-diagonal element)
    coherence = np.abs(result.states[-1].full()[0, 1])
    coherences.append(coherence)
    
    # Effective decoherence rate
    if coherence > 0:
        Î“_eff = -np.log(coherence) / times[-1]
    else:
        Î“_eff = 100  # Large number for complete decoherence
    
    if Î“_env in [Î“_env_values[0], Î“_env_values[len(Î“_env_values)//2], Î“_env_values[-1]]:
        print(f"  Î“_env = {Î“_env:.2e} â†’ Î“_eff = {Î“_eff:.2e}, coherence = {coherence:.3f}")

# ============================================================================
# 4. EXTRACT Î”Î“ AND ANALYZE SHAPE
# ============================================================================
print("\n4. EXTRACTING Î”Î“(âˆšÎ“_env) SIGNATURE")
print("-"*40)

# Convert coherence to total decoherence rate
Î“_tot = -np.log(coherences) / times[-1]
Î”Î“ = Î“_tot - Î“_env_values

# Fit to Model C prediction: Î”Î“ = Î“_grav + 2Ïâˆš(Î“_env Î“_grav)
def model_C_fit(sqrt_Î“_env, Î“_grav, Ï):
    """Î”Î“ = Î“_grav + 2Ïâˆš(Î“_env Î“_grav)"""
    return Î“_grav + 2 * Ï * np.sqrt(sqrt_Î“_env**2 * Î“_grav)

sqrt_Î“_env = np.sqrt(Î“_env_values)
popt, pcov = curve_fit(
    model_C_fit, sqrt_Î“_env, Î”Î“,
    p0=[Î“_grav_fixed, 0.5],
    bounds=([0, 0], [np.inf, 1])
)

Î“_grav_fit, Ï_fit = popt
Î“_grav_err, Ï_err = np.sqrt(np.diag(pcov))

print(f"\nFITTED PARAMETERS:")
print(f"Î“_grav = ({Î“_grav_fit:.3e} Â± {Î“_grav_err:.1e}) s^-1")
print(f"Ï = {Ï_fit:.3f} Â± {Ï_err:.3f}")
print(f"Expected Î“_grav = {Î“_grav_fixed:.3e} s^-1")

# Calculate second derivative to check concavity
spline = UnivariateSpline(sqrt_Î“_env, Î”Î“, k=4)
second_deriv = spline.derivative(n=2)(sqrt_Î“_env[5:-5])  # Avoid edges

print(f"\nCONCAVITY ANALYSIS:")
print(f"Mean second derivative: {np.mean(second_deriv):.2e}")
print(f"Max second derivative: {np.max(second_deriv):.2e}")
print(f"Min second derivative: {np.min(second_deriv):.2e}")
print(f"Sign: {'CONCAVE DOWN' if np.mean(second_deriv) < 0 else 'CONVEX UP'}")

# ============================================================================
# 5. VISUALIZE RESULTS
# ============================================================================
print("\n5. GENERATING PLOTS")
print("-"*40)

fig, axes = plt.subplots(2, 2, figsize=(12, 10))

# Plot 1: Coherence decay for select Î“_env values
ax1 = axes[0, 0]
select_indices = [0, len(Î“_env_values)//2, -1]
colors = ['blue', 'green', 'red']

for idx, color in zip(select_indices, colors):
    Î“_env = Î“_env_values[idx]
    L = two_bath_lindbladian(Î“_env, Î“_grav_fixed, Ï_cross=0.5)
    result = mesolve(L, Ï0, times, [], [])
    coh = [np.abs(state.full()[0, 1]) for state in result.states]
    ax1.semilogy(times, coh, color=color,
                 label=f'Î“_env = {Î“_env:.1e} s$^{{-1}}$')

ax1.set_xlabel('Time (s)')
ax1.set_ylabel('Coherence')
ax1.set_title('Coherence Decay for Different Î“_env')
ax1.legend()
ax1.grid(True, alpha=0.3)

# Plot 2: Î“_tot vs Î“_env
ax2 = axes[0, 1]
ax2.loglog(Î“_env_values, Î“_tot, 'o-', label='Total Î“_tot')
ax2.loglog(Î“_env_values, Î“_env_values, '--', label='Î“_env (no grav)')
ax2.loglog(Î“_env_values, Î“_grav_fixed * np.ones_like(Î“_env_values),
           '--', label='Î“_grav alone')
ax2.set_xlabel('Î“_env (s$^{-1}$)')
ax2.set_ylabel('Î“_tot (s$^{-1}$)')
ax2.set_title('Total Decoherence Rate')
ax2.legend()
ax2.grid(True, alpha=0.3)

# Plot 3: Î”Î“ vs âˆšÎ“_env (Main signature)
ax3 = axes[1, 0]
sqrt_Î“_fine = np.linspace(np.min(sqrt_Î“_env), np.max(sqrt_Î“_env), 100)
Î”Î“_fit = model_C_fit(sqrt_Î“_fine, Î“_grav_fit, Ï_fit)

ax3.plot(sqrt_Î“_env, Î”Î“, 'o', label='Simulation data')
ax3.plot(sqrt_Î“_fine, Î”Î“_fit, '-', label=f'Model C fit\nÎ“_grav={Î“_grav_fit:.1e}\nÏ={Ï_fit:.2f}')
ax3.set_xlabel('âˆšÎ“_env (s$^{-1/2}$)')
ax3.set_ylabel('Î”Î“ (s$^{-1}$)')
ax3.set_title('CONCAVE-DOWN SIGNATURE: Î”Î“ vs âˆšÎ“_env')
ax3.legend()
ax3.grid(True, alpha=0.3)

# Plot 4: Curvature dependence
ax4 = axes[1, 1]
curvatures = np.logspace(-24, -15, 8)
Î“_grav_values = gamma_grav(curvatures)

ax4.loglog(curvatures, Î“_grav_values, 's-')
ax4.axvline(R_earth, color='red', linestyle='--', label='Earth surface')
ax4.axvline(R_neutron, color='orange', linestyle='--', label='Neutron star')
ax4.set_xlabel('Curvature |R| (m$^{-2}$)')
ax4.set_ylabel('Î“_grav (s$^{-1}$)')
ax4.set_title('Model C: Curvature Suppresses Decoherence')
ax4.legend()
ax4.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('model_C_signature.png', dpi=150, bbox_inches='tight')
print("âœ“ Saved plot to 'model_C_signature.png'")

# ============================================================================
# 6. COMPARE WITH OTHER MODELS
# ============================================================================
print("\n6. COMPARISON WITH OTHER MODELS")
print("-"*40)

# Define other models
def model_A_curvature_enhanced(Î“_env, Î“_grav, Ï=0.5):
    """Curvature-enhanced (convex) model"""
    return Î“_env + Î“_grav * (1 + np.sqrt(Î“_env/Î“_grav)) + 2*Ï*np.sqrt(Î“_env*Î“_grav)

def model_B_linear(Î“_env, Î“_grav, Ï=0):
    """Linear (DP-like) model"""
    return Î“_env + Î“_grav

def model_C_screened(Î“_env, Î“_grav, Ï=0.5):
    """Our Model C (from fit)"""
    return Î“_grav + 2*Ï*np.sqrt(Î“_env*Î“_grav)

# Calculate for comparison
Î”Î“_A = model_A_curvature_enhanced(Î“_env_values, Î“_grav_fixed) - Î“_env_values
Î”Î“_B = model_B_linear(Î“_env_values, Î“_grav_fixed) - Î“_env_values
Î”Î“_C = model_C_screened(Î“_env_values, Î“_grav_fit, Ï_fit)

print("\nMODEL DISCRIMINATION (at R_earth):")
print("Model A (convex):  dÂ²Î”Î“/d(âˆšÎ“)Â² > 0")
print("Model B (linear):  dÂ²Î”Î“/d(âˆšÎ“)Â² = 0")  
print("Model C (concave): dÂ²Î”Î“/d(âˆšÎ“)Â² < 0")
print(f"\nOur simulation shows: dÂ²Î”Î“/d(âˆšÎ“)Â² = {np.mean(second_deriv):.2e}")

# ============================================================================
# 7. EXPERIMENTAL SENSITIVITY ESTIMATE
# ============================================================================
print("\n7. EXPERIMENTAL FEASIBILITY")
print("-"*40)

# Current state-of-the-art parameters from Vinante et al. 2024 (order-of-magnitude)
T = 0.1  # K
Ï‰_m = 2*np.pi * 5e3  # Hz
m = 1e-14  # kg
Q = 1e6  # Quality factor

# Thermal decoherence rate (very rough scaling)
Î“_th = k * T / (Ä§ * Q)

# Measurement-limited decoherence
Î“_meas = 1e-4  # Typical from optomechanics

# Total environmental floor
Î“_env_min = max(Î“_th, Î“_meas)
print(f"Minimum achievable Î“_env: {Î“_env_min:.1e} s^-1")

# Signal-to-noise for Model C detection
SNR = Î”Î“[0] / (0.1 * Î”Î“[0])  # Assuming 10% measurement uncertainty
integration_time = 100 / SNR  # Days for SNR=10

print(f"Initial Î”Î“ (at Î“_env_min): {Î”Î“[0]:.1e} s^-1")
print(f"Required integration for SNR=10: {integration_time:.0f} days")

# ============================================================================
# 8. NUMERICAL TESTS + SUMMARY
# ============================================================================
print("\n" + "="*60)
print("SUMMARY: MODEL C VALIDATION")
print("="*60)

tests = {}

# 1. Concavity: mean second derivative must be negative
tests["concave_down"] = (np.mean(second_deriv) < 0)

# 2. Î“_grav recovered within 3Ïƒ of true value
true_G_grav = Î“_grav_fixed
tests["G_grav_within_3sigma"] = abs(Î“_grav_fit - true_G_grav) < 3 * Î“_grav_err

# 3. Ï recovered within 3Ïƒ of true value (0.5)
true_rho = 0.5
tests["rho_within_3sigma"] = abs(Ï_fit - true_rho) < 3 * Ï_err

# 4. Curvature suppression: Î“_grav(neutron) < Î“_grav(earth)
G_earth = gamma_grav(R_earth)
G_neutron = gamma_grav(R_neutron)
tests["curvature_suppression"] = (G_neutron < G_earth)

# 5. Experimental feasibility: integration time <= 7 days for SNR=10
tests["integration_time_ok"] = (integration_time <= 7.0)

def mark(ok):
    return "âœ… PASS" if ok else "âŒ FAIL"

print(f"{mark(tests['concave_down'])} Concave-down signature (mean dÂ²Î”Î“/dxÂ² = {np.mean(second_deriv):.2e})")
print(f"{mark(tests['G_grav_within_3sigma'])} Î“_grav extracted: {Î“_grav_fit:.2e} Â± {Î“_grav_err:.1e} s^-1 (true {true_G_grav:.2e})")
print(f"{mark(tests['rho_within_3sigma'])} Cross-correlation Ï: {Ï_fit:.2f} Â± {Ï_err:.3f} (true {true_rho:.2f})")
print(f"{mark(tests['curvature_suppression'])} Curvature suppression: Î“_grav(neutron) = {G_neutron:.2e}, Î“_grav(earth) = {G_earth:.2e}")
print(f"{mark(tests['integration_time_ok'])} Experimental feasibility: {integration_time:.0f} days for SNR=10")

all_pass = all(tests.values())

print("\nOverall result:")
if all_pass:
    print("ğŸ‰ ALL TESTS PASSED â€” numerical results are consistent with Model C.")
else:
    print("âš ï¸ SOME TESTS FAILED â€” see âŒ flags above for details.")

print("\nCONCLUSION: Model C produces a concave-down Î”Î“ vs âˆšÎ“_env signature")
print("that is numerically testable and distinguishable from linear/convex alternatives.")
print("="*60)
